[
  {
    "objectID": "staff/index.html",
    "href": "staff/index.html",
    "title": "Staff",
    "section": "",
    "text": "Fabian Faßnach\n\n\n\n\n\n\nRemote sensing & geoinformatics group\n\n\nMar 9, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarion Stellmes\n\n\n\n\n\n\nRemote sensing & geoinformatics group\n\n\nMar 9, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "RESEDA/contents/PrepareYourself.html",
    "href": "RESEDA/contents/PrepareYourself.html",
    "title": "Prepare Yourself",
    "section": "",
    "text": "Prepare Yourself\n\n\nThis chapter guides you on how to get all the necessary software you will need for this online course and introduce you to the fundamental layout of several useful programs. We will use a Virtual Machine (VM) which comes with all the software we need. Read on to find out what it is all about!\n\nChapter in a Box\nIn this chapter, the following content awaits you:\nIntro\n– virtual machines explained\nGet Your VM\n– download your own virtual machine\n– get guided how to install our virtual machine using VirtualBox\nR-Studio\n– introduction to R-Studio user interface\n– instructions how to execute R commands in R-Studio\nQGIS\n– introduction to QGIS user interface\nSNAP\n– introduction to SNAP user interface\nR Crash Course\n– get a basic understanding of data types in R\n– prove your understanding with a lot of exercises\n\n\nVirtual Machines Explained\nInstallations and updates of software packages are always a little annoying, no doubt. Often one software is being actively developed and updated, while others are not. This propably leads to modified functionalities or communication problems between programs. Unfortunately, we will need to work with several separate software bundles in order to achieve our goals…\nBut there is no cause for concern – because we have prepaired your very own VirtualBox image! You are right to ask: What does it mean?\nVirtualBox is a cross-platform virtualization application. It installs a new virtual operating system (Virtual Machine, VM) on your computer, regardless of which system you currently use (e.g., Windows, Mac, Linux). Just think about VirtualBox as any other program, which you can easily delete if you want to get rid of it. It does not affect your underlying operating system in any way!\nWell, so why are we using this system? Within the VirtualBox image all required software is already installed and ready to use. This means that once the image is installed, there are no more installations and updates to worry about! Hooray!\nThere are several other advantages in using a VM, e.g., you can run multiple operating systems simultaneously, test new software, and switch back to a previous state or backup of your VM if something went terribly wrong. Read here for a more detailed explanation.\nOf course, the VirtualBox is not mandatory, it is just an offer that makes things easier if you are not familar with remote sensing software. You are free to install each software package by your own. The individual programs are listed and linked hereinafter. Be aware that thereby programs might differ in appearance and output from what is shown in this online course.\nHowever, we recommend to use a computer with at least 8 gb of main memory (RAM), as remote sensing datasets are often very large and their processing computational demanding. Additionally you will need approximately 10 gb of free disk space on your harddrive.\nIn future, every effort will be made on our part to ensure that the programs within the VirtualBox are properly working and updated. However, information given comes without warranty, either express or implied. Neither the authors, nor Freie Universitaet Berlin will be held liable for any damages caused or alleged to be caused directly or indirectly by provided software.\nIf you find any problems or errors we would appreciate if you contact us.\n\n\n\n\nSoftware included in our VM\nAll provided computer programs as well as the operating system itself (Linux Debian) are free and open-source. That is, you are freely licensed to use, copy, study and change the software in any way. The following overview lists all programs we need for this online course. Use this list in case you want to install everything by your own. However, do not download each one individually if you want to use our VirtualBox (Get Your VM). A detailed step-by-step guide for the VM installation is given in the next section.\n\nR – Progamming language\nR-Studio – Integrated development environment\nSNAP – Remote sensing software\nQGIS – Geographic Information System\nBulk Download Application – Software for Bulk Downloading of remote sensing data\nGDAL – Geospatial Data Abstraction Library"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-V/R–ExerciseV.html",
    "href": "R-Crash-Course/contents/Part-V/R–ExerciseV.html",
    "title": "R – Exercise V",
    "section": "",
    "text": "R – Exercise V\n\n\n\nUse ifelse() and your data frame df from exercise IV: If the person is less than or equal to 175 cm, it should have the attribute “small”, otherwise “tall”. Save the result in your df as the new column size.category.\n\nx &lt;- ifelse(df$size &lt;= 175, \"small\", \"tall\")\n\nx\n## [1] \"small\" \"small\" \"tall\" \"tall\" \"small\"\n\ndf$size.categorie &lt;- x\n\ndf\n##    name age size    city weight size.categorie\n## 1  Anna  66  170 Hamburg  115.0          small\n## 2  Otto  53  174  Berlin  110.2          small\n## 3 Natan  22  182  Berlin   95.0          tall\n## 4   Ede  36  180 Cologne   87.0          tall\n## 5  Anna  32  174 Hamburg   63.0          small\n\nWrite a loop that outputs all integers from 5 to 15!\n\nvektor &lt;- 5:15\nvektor\n##  [1]  5  6  7  8  9 10 11 12 13 14 15\n\nfor (i in vektor) {\n  print(i)\n}\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n## [1] 10\n## [1] 11\n## [1] 12\n## [1] 13\n## [1] 14\n## [1] 15\n\nAdvanced: Create a for loop that outputs the arithmetic mean for each variable (column) of your data frame df – provided that the variable is numeric!\n\nfor (i in 1:ncol(df)) {\n  \n  if (class(df[[i]]) == \"numeric\") {\n    print(names(df)[i])\n    result &lt;- mean(df[[i]], na.rm=TRUE)\n    print(result)\n  }\n  \n}\n## [1] \"age\"\n## [1] 41.8\n## [1] \"size\"\n## [1] 176\n## [1] \"weight\"\n## [1] 94.04\n\n# Even if it looks complicated, take your time and go through it line by line. Everything should be known by now!"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-IV/R–ExerciseIV.html",
    "href": "R-Crash-Course/contents/Part-IV/R–ExerciseIV.html",
    "title": "R – Exercise IV",
    "section": "",
    "text": "R – Exercise IV\n\n\n\nCreate a data frame df that contains the following variables for at least four observations:\n\n\nname: name of at least four friends or acquaintances\nage: the age of those persons\nsize: the height of those persons in cm\ncity: Place of residence of those persons (city)\n\ndf &lt;- data.frame(\n  name = c(\"Anna\", \"Otto\", \"Natan\", \"Ede\"), \n  age  = c(66, 53, 22, 36),\n  size = c(170, 174, 182, 180),\n  city = c(\"Hamburg\", \"Berlin\", \"Berlin\", \"Cologne\")\n  )\n\ndf\n##    name age size    city\n## 1  Anna  66  170 Hamburg\n## 2  Otto  53  174  Berlin\n## 3 Natan  22  182  Berlin\n## 4   Ede  36  180 Cologne\n\nExamine the dimensionality, structure and statistical summary of your data frame df!\n\ndim(df)\n## [1] 4 4\n\nstr(df)\n## 'data.frame':    4 obs. of  4 variables:\n##  $ name: Factor w/ 4 levels \"Anna\",\"Ede\",\"Natan\",..: 1 4 3 2\n##  $ age : num  66 53 22 36\n##  $ size: num  170 174 182 180\n##  $ city: Factor w/ 3 levels \"Berlin\",\"Cologne\",..: 3 1 1 2\n\nsummary(df)\n##     name        age             size            city  \n##  Anna :1   Min.   :22.00   Min.   :170.0   Berlin :2  \n##  Ede  :1   1st Qu.:32.50   1st Qu.:173.0   Cologne:1  \n##  Natan:1   Median :44.50   Median :177.0   Hamburg:1  \n##  Otto :1   Mean   :44.25   Mean   :176.5              \n##            3rd Qu.:56.25   3rd Qu.:180.5              \n##            Max.   :66.00   Max.   :182.0\n\nIndex the second column with simple square brackets [] and save the output as df.subset! Which class does the output belong to?\n\ndf.subset &lt;- df[2]\n\ndf.subset\n##   age\n## 1  66\n## 2  53\n## 3  22\n## 4  36\n\nclass(df.subset)\n## [1] \"data.frame\"\n\nIndex the variable age with double square brackets [\\[\\[\\]]]{.crayon-inline} and save the output as age.persons. Which class does the output belong to?\n\nage.persons &lt;- df[[\"alter\"]]\n\n# oder\n\nage.persons &lt;- df[[2]]\n\nage.persons\n## [1] 66 53 22 36\n\nclass(age.persons)\n## [1] \"numeric\"\n\nAdd the variable weight in kg to the data frame df!\n\ndf$weight &lt;- c(115, 110.2, 95, 87)\n\ndf\n##    name age size    city weight\n## 1  Anna  66  170 Hamburg  115.0\n## 2  Otto  53  174  Berlin  110.2\n## 3 Natan  22  182  Berlin   95.0\n## 4   Ede  36  180 Cologne   87.0\n\nAdd another observation (person) to your df!\n\nnew.person &lt;- data.frame(\n  \"name\"   = \"Anna\",\n  \"age\"    = 32,\n  \"size\"   = 174,\n  \"weight\" = 63,\n  \"city\"   = \"Hamburg\"\n)\n\ndf &lt;- rbind(df, new.person)\n\ndf\n##    name age size    city weight\n## 1  Anna  66  170 Hamburg  115.0\n## 2  Otto  53  174  Berlin  110.2\n## 3 Natan  22  182  Berlin   95.0\n## 4   Ede  36  180 Cologne   87.0\n## 5  Anna  32  174 Hamburg   63.0\n\nCalculate the mean value of the variable age and save the result as ages.mean!\n\nages.mean &lt;- mean(df$age)\n\nIndex all observations (persons) that are older than the average ages.mean!\n\ndf[df$age &gt; ages.mean, ]\n\nIndex all persons, which are lighter than 100 kg AND at least 180 cm tall!\n\ndf[df$weight = 180, ]\n##    name age size    city weight\n## 3 Natan  22  182  Berlin     95\n## 4   Ede  36  180 Cologne     87\n\n# or\n\nsubset(df, df$weight = 180)\n##    name age size    city weight\n## 3 Natan  22  182  Berlin     95\n## 4   Ede  36  180 Cologne     87"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-III/R–ExerciseIII.html",
    "href": "R-Crash-Course/contents/Part-III/R–ExerciseIII.html",
    "title": "R – Exercise III",
    "section": "",
    "text": "R – Exercise III\n\n\n\nCreate a matrix named m1 with three rows and five columns and all the numeric (integer) values from 6 to 20!\n\nm1 &lt;- matrix(6:20, nrow = 3, ncol = 5)\n\nm1\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    6    9   12   15   18\n## [2,]    7   10   13   16   19\n## [3,]    8   11   14   17   20\n\nMultiply all elements in m1 by 0.5! Overwrite the matrix m1 with the result!\n\nm1 &lt;- m1 * 0.5\n\nCreate another matrix m2 with one row and five columns and all the numeric (integer) values from 1 to 5!\n\nm2 &lt;- matrix(1:5, nrow = 1, ncol = 5)\n\nm2\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    2    3    4    5\n\nCalculate the sum of all elements in m2!\n\nsum(m2)\n## [1] 15\n\nCombine m1 and m2 with rbing(). Save the result as m3 and check the dimension of the new matrix!\n\nm3 &lt;- rbind(m1, m2)\n\nm3\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]  3.0  4.5  6.0  7.5  9.0\n## [2,]  3.5  5.0  6.5  8.0  9.5\n## [3,]  4.0  5.5  7.0  8.5 10.0\n## [4,]  1.0  2.0  3.0  4.0  5.0\n\ndim(m3)\n## [1] 4 5\n\nIndex the 5th column of m3!\n\nm3[ , 5]\n## [1]  9.0  9.5 10.0  5.0\n\nIndex the 2nd and 4th lines of m3!\n\nm3[ c(2, 4), ]\n##      [,1] [,2] [,3] [,4] [,5]\n## [1,]  3.5    5  6.5    8  9.5\n## [2,]  1.0    2  3.0    4  5.0\n\nCalculate the sums for all columns in m3!\n\ncolSums(m3)\n## [1] 11.5 17.0 22.5 28.0 33.5\n\nCalculate the standard deviation for the 3rd column in m3!\n\nsd( m3[ , 3] )\n## [1] 1.796988\n\nFrom m3, index the element in the 2nd column and 2nd line and all eight adjacent elements! Save the result as m4 and examine its object class!\n\nm4 &lt;- m3[2:4, 2:4]\n\nm4\n##      [,1] [,2] [,3]\n## [1,]  5.0  6.5  8.0\n## [2,]  5.5  7.0  8.5\n## [3,]  2.0  3.0  4.0\n\nclass(m4)\n## [1] \"matrix\""
  },
  {
    "objectID": "R-Crash-Course/contents/Part-II/R–ExerciseII.html",
    "href": "R-Crash-Course/contents/Part-II/R–ExerciseII.html",
    "title": "R – Exercise II",
    "section": "",
    "text": "R – Exercise II\n\n\n\nCreate an integer variable e holding the value 42! Check the object class of e with class()!\n\ne &lt;- 42L\n\nclass(e)\n## [1] \"integer\"\n\nConvert e to the character data type with as.character()! Check the object class again!\n\ne &lt;- as.character(e)\n\nclass(e)\n## [1] \"character\"\n\nCreate a character vector friends with four names from your circle of friends or acquaintances!\n\nfriends &lt;- c(\"Anna\", \"Otto\", \"Natan\", \"Ede\")\n\nfriends\n## [1] \"Anna\"  \"Otto\"  \"Natan\" \"Ede\"\n\nIndex the second element from the vector friends!\n\nfriends[2]\n## [1] \"Otto\"\n\nReplace the first element of the vector friends with “Isolde” and check the updated vector again!\n\nfreunde[1] &lt;- \"Isolde\"\n\nfreunde\n## [1] \"Isolde\" \"Otto\"   \"Natan\"  \"Ede\"\n\nCreate a vector v1 from the following elements  1, “Hello”, 2, “World” ! Check the object class!\n\nv1 &lt;- c(1, \"Hello\", 2, \"World\")\n\nv1\n## [1] \"1\"     \"Hello\" \"2\"     \"World\"\n\nclass(v1)\n## [1] \"character\"\n\nCreate a vector v2 with numerical values ​​(only integers) ranging from 4 to 10!\n\nv2 &lt;- c(4, 5, 6, 7, 8, 9, 10)\n\nv2\n## [1]  4  5  6  7  8  9 10\n\n# or use the sequence operator \":\"\n\nv2 &lt;- c(4:10)\n\nv2\n## [1]  4  5  6  7  8  9 10\n\nIndex the first three elements from v2!\n\nv2[1:3]\n## [1] 4 5 6\n\n# or:\n\nv2[ c(1, 2, 3) ]\n## [1] 4 5 6\n\nIndex all elements of v2 except the second element and save the result as v2.subset!\n\nv2.subset &lt;- v2[-2]\n\nv2.subset\n## [1]  4  6  7  8  9 10\n\nUse the length () function to find out the length of v2.subset (= the number of elements in the vector)!\n\nlength(v2.subset)\n## [1] 6\n\nCalculate the arithmetic mean of vector v2! In addition, determine the standard deviation of v2.subset!\n\nmean(v2)\n## [1] 7\n\nsd(v2.subset)\n## [1] 2.160247"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-I/R–ExerciseI.html",
    "href": "R-Crash-Course/contents/Part-I/R–ExerciseI.html",
    "title": "R – Exercise I",
    "section": "",
    "text": "R – Exercise I\n\n\nWelcome to your first training session!\nNo need to be nervous: this page contains not only tasks, but also their solutions as folded code elements. You can unfold these code blocks by simply clicking on them. Give it a try:\n# Well done!\n\n# Spoiler! -  you will find your answer here\n\nCreate a variable called a and assign the number 2017 to it!\n\n# use the \"&lt;-\" operator for variable assignments:\na &lt;- 2017\n\nCalculate the square root of 1089 and save the result in variable b!\n\n# use the built- in function \"sqrt()\" and the number 1089 as an argument:\nb &lt;- sqrt(1089)\n\nCalculate the sum of a and b!\n\n# done via standard operators:\na + b\n## [1] 2050\n\nOverwrite variable a by assigning the value 2018 to it!\n\n# simply assign a new value to an existing variable in order to overwrite it\na &lt;- 2018\n\nMake a copy of variable b and name it c!\n\n# variable assignment works from right (existing variable) to left (new variable):\nc &lt;- b\n\nCreate your own function called my.fun(), which requires three variables as input. The function should generate the square root of the product of all three variables and return one numeric value!\n\nmy.fun &lt;- function( var1, var2, var3 ) {\n  result &lt;- sqrt( var1 * var2 * var3 )\n  return(result)\n}\n\nUse a, b and c (from the previous tasks) as input into my.fun() and save the output to variable d! Check the resulting value!\n\nd &lt;- my.fun(a, b, c)\nd\n## [1] 1482.431"
  },
  {
    "objectID": "quarto-website-template-main/cv/index.html",
    "href": "quarto-website-template-main/cv/index.html",
    "title": "Curriculum vitae",
    "section": "",
    "text": "Download current CV\n  \n\n\n  \n\n\nView the tutorial for this template (+ download link)"
  },
  {
    "objectID": "projects/posts/welcome/index.html",
    "href": "projects/posts/welcome/index.html",
    "title": "MOFA",
    "section": "",
    "text": "Monitoring Farmland Abandonment by multitemporal and multisensor remote sensing imagery (MOFA)\n\nThe research project studies an area in the border region of Poland and Ukraine. With the fall of the Iron Curtain the region experienced drastic changes in political and socio- economic structures. Large farmland areas become abandoned and gradual processes of forest succession take place on the abandoned land. The aim of the project is the development of adequate strategies to monitor farmland abandonment, using multitemporal SAR and multispectral remote sensing data.\n\n\n\nFinally enhanced maps should be provided, which enable more detailed analysis of the gradual process of land cover transitions. (PI: B. Waske, funding: German Research Foundation (DFG) WA 2728/2-1)\nThus, remote sensing based mapping offers great opportunities to map these phenomena and ultimately to better understand patterns, processes and underlying causes. Existing studies are based on multispectral imagery, abandonment maps, however, are difficult to obtain due to spectral ambiguities, phenological variability and limited data availability. SAR data can overcome these problems and different remote sensing studies demonstrated the potential of multisensor imagery. The aim of the project is the development of adequate strategies to monitor farmland abandonment, using multitemporal SAR and multispectral remote sensing data. Finally enhanced maps should be provided, which enable more detailed analysis of the gradual process of land cover transitions.\nThe study site within the border region of Poland and Ukraine (© Google, 2012)\n\n\nProject Duration: 01/2012 - 12/2014\nPrincipal Investigator: Björn Waske\nProjects staff: Jan Stefanski (University Bonn)\nProject partners:\nProf. Dr. Tobias Kümmerle, Biogeography and Conservation Biology Group, Humboldt-University of Berlin\nDr. Oleh Chaskovskyy, Ukrainian National Forestry University, Lviv (Ukraine)\nDr. hab. Jacek Kozak, Department of GIS, Cartography and Remote Sensing, Jagiellonian University, Kraków (Poland)\nFunding: DFG - German Research Foundation (WA 2728/2-1)"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Research projects",
    "section": "",
    "text": "Future Forest\n\n\n\n\n\n\n\nOngoing\n\n\nsentinel-2\n\n\nforest damage\n\n\n\n\n\n\n\n\n\n\n\nMar 9, 2024\n\n\nRemote sensing & geoinformatics group\n\n\n\n\n\n\n  \n\n\n\n\nMOFA\n\n\n\n\n\n\n\nCompleted\n\n\nmultitemporal\n\n\nmultisensor\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2014\n\n\nBjörn Waske\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "About/index.html",
    "href": "About/index.html",
    "title": "About",
    "section": "",
    "text": "Freie Universität Berlin – represented by the President –\n\n\n\nFreie Universität Berlin\nOffice of the President\nKaiserswerther Str. 16/18\n14195 Berlin\n\n\n\nDE 811304768\n\n\n\nM.Sc. Johannes Rosentreter (Web content development)\nE-mail: rosentreter.johannes@gmail.de\nPhone:\nDipl.-Ing. Kristin Fenske (Web content development)\nE-mail: kristin.fenske@fu-berlin.de\nPhone: (+49 30) 838 65326\nProf. Dr. Hannes Feilhauer (Content-related support)\nE-mail: hfeilhauer@zedat.fu-berlin.de\nPhone: (+49 30) 838 66172\nDr. Marion Stellmes (Content-related support)\nE-mail: marion.stellmes@fu-berlin.de\nPhone: (+49 30) 838 61978\nDipl. Geog. Rolf Rissiek (Laboratory assistance)\nE-mail: rolf.rissiek@fu-berlin.de\nPhone: (+49 30) 838 70263\n\n\n\nSee our Privacy Policy\n\n\n\nFreie Universität Berlin is a statutory body under public law in accordance with §§1 and 2 of the Berlin Law Relating to Institutions of Higher Learning (Berliner Hochschulgesetz, BerlHG). The web site of Freie Universität Berlin is subject to current copyright law. Please also take notice of our disclaimer."
  },
  {
    "objectID": "About/index.html#institution",
    "href": "About/index.html#institution",
    "title": "About",
    "section": "",
    "text": "Freie Universität Berlin – represented by the President –"
  },
  {
    "objectID": "About/index.html#address",
    "href": "About/index.html#address",
    "title": "About",
    "section": "",
    "text": "Freie Universität Berlin\nOffice of the President\nKaiserswerther Str. 16/18\n14195 Berlin"
  },
  {
    "objectID": "About/index.html#turnover-tax-id",
    "href": "About/index.html#turnover-tax-id",
    "title": "About",
    "section": "",
    "text": "DE 811304768"
  },
  {
    "objectID": "About/index.html#web-content-editors",
    "href": "About/index.html#web-content-editors",
    "title": "About",
    "section": "",
    "text": "M.Sc. Johannes Rosentreter (Web content development)\nE-mail: rosentreter.johannes@gmail.de\nPhone:\nDipl.-Ing. Kristin Fenske (Web content development)\nE-mail: kristin.fenske@fu-berlin.de\nPhone: (+49 30) 838 65326\nProf. Dr. Hannes Feilhauer (Content-related support)\nE-mail: hfeilhauer@zedat.fu-berlin.de\nPhone: (+49 30) 838 66172\nDr. Marion Stellmes (Content-related support)\nE-mail: marion.stellmes@fu-berlin.de\nPhone: (+49 30) 838 61978\nDipl. Geog. Rolf Rissiek (Laboratory assistance)\nE-mail: rolf.rissiek@fu-berlin.de\nPhone: (+49 30) 838 70263"
  },
  {
    "objectID": "About/index.html#privacy-statement",
    "href": "About/index.html#privacy-statement",
    "title": "About",
    "section": "",
    "text": "See our Privacy Policy"
  },
  {
    "objectID": "About/index.html#legal-form",
    "href": "About/index.html#legal-form",
    "title": "About",
    "section": "",
    "text": "Freie Universität Berlin is a statutory body under public law in accordance with §§1 and 2 of the Berlin Law Relating to Institutions of Higher Learning (Berliner Hochschulgesetz, BerlHG). The web site of Freie Universität Berlin is subject to current copyright law. Please also take notice of our disclaimer."
  },
  {
    "objectID": "About/cv.html",
    "href": "About/cv.html",
    "title": "Curriculum vitae",
    "section": "",
    "text": "Download current CV\n  \n\n\n  \n\n\nView the tutorial for this template (+ download link)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Github\n  \n  \n    \n     Email\n  \n  \n    \n     \n  \n\n  \n  \n\nWelcome\nto your Remote Sensing Data Analysis online course, or RESEDA for short!\nThis course helps you improve your analysis of remote sensing image data for the next data science project or thesis. We will have a look at basic and advanced concepts needed for a complete project implementation using remote sensing imagery – with a special focus on automatisation of individual operations and big data processing. This course will provide a great deal of knowledge and valuable expertise for all related fields of environmental earth sciences!\nFor that purpose we will mainly use the statistical programming language R in a Linux environment – but please don’t panic, it’s not as bad as it sounds: You will be led through a complete analysis process, from data acquisition, to import, exploration and finally the export of your results, guided by a lot of reproduceable examples, exercises and pretty pictures!\nKeep in mind that this course content complements and extends the material covered in the classes Fernerkundung und Digitale Bildverarbeitung and Geographische Informationssysteme, both being taught at the Freie Universität Berlin.\nPlease feel free to contact us if you have any questions or would like to discuss potential projects.\n\n\n\n\n\nBest regards, your FU Berlin Remote Sensing and Geoinformatics staff"
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Welcome",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nThis online course is divided into separate sections covering particular topics, which together provide a whole workflow commonly used for remote sensing imagery. Although the sections are built on one another and we recommend to handle them in given order, feel free to skip parts you are already comfortable with and focus on the chapters you are interested in. In almost every section you will come across exercises, e.g., multiple choice questionnaires or coding exercises to proof your comprehension of previous sections.\nLet us have a look at the learning objectives and checkpoints of each individual section:\n\nPrepare Yourself\ninstall our VirtualBox containing all required software get used to the GUIs of R-Studio, QGIS and SNAP refresh basics of the programming language R (if needed)\n\n\nAcquire Data\n\nrepeat basics of optical and radar imagery\nbecome familiar with online data provider and HUBs\nautomatically download many images using bulk downloads\n\n\n\nAnalyse Your Data\n\nrepeat basics of classification and regression tasks\nclassify image data in R with Random Forest and SVM\nvisualize results in R and QGIS\n\n\n\nValidate Results\n\nrepeat validation basics\nvalidate results in R with state of the art methods\n\n\n\nSAR Processing\n\nget deeper insights in SAR processing\nprocess Sentinel imagery in SNAP\nlearn to do InSAR and texture analysis\n\nWe wish you a lot of creative ideas, much findings and great results!\nBest regards, your FU Berlin Remote Sensing and Geoinformatics staff"
  },
  {
    "objectID": "projects/posts/post-with-code/index.html",
    "href": "projects/posts/post-with-code/index.html",
    "title": "Future Forest",
    "section": "",
    "text": "The aim of FutureForest is to use artificial intelligence (AI) methods to provide information that can support climate-adapted forest conversion.\nOngoing Projects\n\nFutureForest (future-forest.eu): The aim of FutureForest is to use artificial intelligence (AI) methods to provide information that can support climate-adapted forest conversion. The effects of different climate forecasts and forest conversion scenarios are to be simulated and the possible effects of different management methods are to be assessed. Main tasks of FU Berlin include:\n\nSentinel-2 time series based detection of forest damaged areas in Germany\nOperational \"near real-time\" monitoring using Deep Learning\n\n\n\nEarly detection of damaged areas\nProvision of a Germany-wide map of current forest damage/warnings\n\nUAV based analysis of the deciduous forests under drought stress in the historical garden districts of Berlin and Potsdam in 2020 (in cooperation with „Stiftung Preußische Schlösser & Gärten Berlin-Brandenburg” (SPSG) and „Grünflächenamt Berlin Steglitz-Zehlendorf”\n\nYou can visit the live dashboard of the Installation site here."
  },
  {
    "objectID": "quarto-website-template-main/404.html",
    "href": "quarto-website-template-main/404.html",
    "title": "404",
    "section": "",
    "text": "Page not found, sorry! Try the search or navigate back to the base website."
  },
  {
    "objectID": "R-Crash-Course/contents/Part-I/index.html",
    "href": "R-Crash-Course/contents/Part-I/index.html",
    "title": "Part I",
    "section": "",
    "text": "Part I\n\n\n\n1. Package Management\nPackages are collections of functions and compiled code written by the R community or the R Development Core Team. R comes with a standard set of packages, e.g., base, stats, and graphics. However, R is enormously expandable in its (geo-)statistical functionality via the official network CRAN (The Comprehensive R Archive Network). There are over 11,000 different extensions, or packages, available free of charge. The directory, where installed packages are stored, is called library.\nYour can install new packages to your library by clicking on the Packages-tab and then Install in the Files Pane of R-Studio. Anyway, download and installation of packages can also be done script-based via the function install.packages() (illustrated using the ggplot2 package, which is useful for creating elegant data visualizations):\ninstall.packages(\"ggplot2\")\n\nlibrary()\nThe function library() in line 3 lists all currently installed packages on your system. This list is also visible in the Files Pane of R-Studio (Packages tab). Keep in mind that packages must be installed only once and remain permanently installed, even after a restart of R-Studio.\nOnce installed, you have to load the package into your current R-session before you can use its functionalities by using library() together with the package name:\nlibrary(ggplot2)    \nYou can list all packages, which are loaded in your current R session by using search(). Activated packages also have a tick symbol next to their names in the Files pane (Packages tab) of R-Studio.\n\n\n\n\n2. Calculate With R\nOf course, R can be used as a simple calculator. Required operators can be entered directly into the Console pane of R-Studio or as a whole script in the Source Pane, from which you can send the commands to the Console pane with Ctrl+Enter. Results are then immediately printed to the console. In this online course, corresponding outputs are also shown with two hash tags at the beginning of the line for better transparency and readability:\n# hash tags allow you to make valuable notes and reminders \n\n19 + 23      \n## [1] 42\n\n34 - 22     \n## [1] 12\n\n27 / 9       \n## [1] 3\n\n6 * 8        \n## [1] 48\n\n(2 + 3) * 4  \n## [1] 20\nYou will see a number in square brackets [1] at the beginning of your output prompts. This number refers to the length of your output, i.e., the number of elements, which is 1 for all examples above. More on that in chapter Vectors. In addition to these standard operators, there were plenty of other operators commonly encountered in R:\n\n\n\n\n\n\n\n  ?  \nhelp function\n\n\n  +   –   /   *   ^  \naddition, subtraction, division, multiplication, potentiation\n\n\n  !  \nnegation sign\n\n\n  &lt;   &gt;   &lt;=   &gt;=   ==   !=  \nlesser, greater, lesser or equal, greater or equal, equal, not equal\n\n\n  &   |  \nboolean AND, boolean OR\n\n\n  &lt;-  \nvariable assignment\n\n\n  ~  \nseparate left- and right-hand sides in a model formula\n\n\n  :  \ngenerate regular sequences\n\n\n  %%  \nmodulo\n\n\n[  [[]]  $  @\nindexing in vectors, matrices, and data frames\n\n\n\nThe help operator in R provides access to the documentation pages for R functions, data sets, and other objects, both for packages in the standard R distribution and for contributed packages. In order to access documentation for the sequence operator, for example, enter the command ?“:” or help(“:”).\n\n\n\n\n3. Variables\nIn most cases, however, you will want to cache results of commands in order re-access them later on. Then, variables come into play. In R variables are defined using the  &lt;-  operator. Although the output will not be printed to the Console pane directly, we store the variable in our temporary workspace. Thus, the variable should be visible under Values ​​in the Environment pane in R-Studio.\nx &lt;- 8 + 7         # assignment to variable x\n\ny &lt;- 4 * 2         # assignment to variable y\nWe only get the value of the variable when we call its name as a command or look into the Environment pane. Further calculations with the variables are also possible:\nx            \n## [1] 15\n\ny  \n## [1] 8\n\nx + y        \n## [1] 23\n\nmy.variable &lt;- x + y\nmy.variable \n## [1] 23\nA convention in R is to include points in variable names, e.g., my.variable. This is for the sake of clarity only, especially when many variables exist, and has no deeper meaning beyond that. Strictly avoid any other special symbols in variable names.\n\n\n\n\n4. Functions\nA function is a piece of code written to carry out a specific task. It can accept arguments and returns one or more values.\nR standard packages offer several arithmetic built-in functions and constants, which make statistical analysis quite efficient. A function generally consists of a function name and two parentheses  () , in which arguments are given as input. Of course, previously created variables can serve as arguments for functions, too:\nsqrt(64)           # square root \n## [1] 8\n\nexp(3)             # exponential\n## [1] 20.08554\n\ncos(13)            # cosinus\n## [1] 0.9074468\n\npi                 # constant number pi\n## [1] 3.141593\n\nround(pi)          # round values\n## [1] 3\n\na &lt;- 6\nb &lt;- 9.2\nlog10(a + b)       # logarithm (base 10)\n## [1] 1.181844\nSo, the best way to learn about the internal workings of a function is to write your own one. R allows to create user defined functions, whereby the basic construct of each function is the following:\nname.of.fun( arguments ) { body }\nThe code in between the curly braces is the body of the function. This is where you define all the commands your functions will perform. Let us write a function that calculates a normalized ratio of two numeric values! It is best to copy the following code into the script window, select everything and then execute the code. The function should then appear in the Environment window and can be called hereinafter.\nmy.fun &lt;- function(var1, var2) {\n  x &lt;- (var1 - var2) / (var1 + var2)\n  return(x)\n}\nExplanation: Use function() to create a new function and assign it to any variable, e.g.,my.fun. The two arguments var1 and var2 are placeholders for variables that are assigned when this function is called. Operations of the function are defined between the curly braces {}. Intermediate results, i.e., the x in our example, exist locally within the function – they do not appear in the Environment window. Only variables given to the return function can be saved as a variable. The function call is done via:\nresult &lt;- my.fun(42, 13)\nresult \n## [1] 0.5272727\nIf you feel ready click the button below and check your understanding up to here!"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-II/index.html",
    "href": "R-Crash-Course/contents/Part-II/index.html",
    "title": "Part II",
    "section": "",
    "text": "Part II\n\n\n\n5. Vectors\nIn R data can be represented in different structure types. Four main types are differentiated: vectors, matrices, lists and data frames. A conversion of these is possible with the corresponding functions as.vector(), as.matrix(), as.list(), or as.data.frame().\nLet us have a look at the most basic of those data types: vectors.\nThere are six atomic vector types in R. In this context, “atomic” means that vectors contain only elements belonging to one of the following classes:\n\n\n\nclass\nexamples\n\n\ncharacter\n“time”, “space”, “R is a lot of fun!”\n\n\nnumeric/ double\n3, -8, -14.4, 56.8\n\n\ninteger\n5, 9, 23, 654\n\n\nlogical\nTRUE, FALSE\n\n\ncomplex\n1 + 2i, 3-6i\n\n\nraw\nraw sequences of bytes\n\n\n\nThus, a vector is a simple collection of elements (e.g., character, integer, …) containing only objects of the same class. Imagine a vector like a sequence of cells containing data. Vectors of different types can be generated via the c() function (“c” like combine):\n\na &lt;- c(\"Hello\", \"World\")    # character/ string \n\nclass(a)\n## [1] \"character\"\n\nb &lt;- c(1.3, 5.6, 3.0)       # numeric \nclass(b)\n## [1] \"numeric\"\n\nc &lt;- c(42L, 99L, 46L)       # integer \nclass(c)\n## [1] \"integer\"\n\nd &lt;- c(TRUE, TRUE, FALSE)   # logical \nclass(d)\n## [1] \"logical\"\n\ne &lt;- c(1 + 2i, 3-6i)        # complex \nclass(e)\n## [1] \"complex\"\n\nlength(a)                   # get number of elements in vector\n## [1] 2\nInteger values ​​must be explicitly declared with an “L”, otherwise they are considered numeric or double.\nEverything in R is an object that belongs to certain classes. This is because R is subject to an object-oriented paradigm. However, within this course, we only focus on the relevant aspects of object orientation in order not to go beyond the scope.\nObjects have different properties, or attributes, such as column names, dimensionality, length or class membership, and many more. These attributes can be queried using, for example, class() or length() function (like above).\nThe official cheat sheets also provide a very good overview of data types and their most important properties.\nIf several classes are combined in one vector, the conversion into a uniform class is automatically forced:\nab &lt;- c(\"Hello\", 1.3, \"World\", 5.6)   \nclass(ab)\n## [1] \"character\"\n\nab\n## [1] \"Hello\" \"1.3\"   \"World\" \"5.6\"\n\n\ncd &lt;- c(TRUE, 45L, FALSE, 13L)\nclass(cd)\n## [1] \"integer\"\n\ncd\n## [1]  1 45  0 13\nIt should be noted that the elements are then partially modified (TRUEbecomes the numeric value 1)!\nConversions between classes is also possible. But when you try to convert a character vector to numeric values, NA values ​​(NA for not available) are introduced:\nx &lt;- c(0L, 1L, 2L, 3L, 4L, 5L) \nx\n## [1] 0 1 2 3 4 5\n\nx &lt;- as.character(x)\nx\n## [1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\"\n\ny &lt;- c(\"R\", \"is\", \"fun\")\ny\n## [1] \"R\"   \"is\"  \"fun\"\n\ny &lt;- as.numeric(y)\n## Warning message: NAs introduced by coercion \n\ny\n## [1] NA NA NA\nIndexing in vectors\nTo address individual elements in our vector, we must “index” it. We index something in R by using square brackets [] . Counting starts at 1 – so we get the first element of the vector with \\[1\\]. If the index number is greater than the length of the vector, NA values ​​are obtained.\nSince a vector is one-dimensional, we only need to write one number as an index between the square brackets in order to retrieve the respective entry. A minus sign in front of the index number leads to an exclusion of the respective entry:\nx &lt;- c(4, 2, 7, 9, 3) \nx\n## [1] 4 2 7 9 3\n\nx[1]           # first element\n## [1] 4\n\nx[-3]          # all but the third element\n## [1] 4 2 9 3\n\nx[2:4]         # all elements from second to fourth entry\n## [1] 2 7 9\n\nx[c(2, 5)]     # only the second and fifth element\n## [1] 2 3\nCalculate with vectors\nNumerical vectors are calculated element by element. By multiplying a vector with the value 5, we again get a vector of the same length in which each element has been multiplied by 5:\nv1 &lt;- c( 1,  3,  5,  7)\n\nv1 * 5\n## [1]  5 15 25 35\n\nv1 + 100\n## [1] 101 103 105 107\nIf we have two vectors of the same length, we can compute them both element by element, so the first element of one vector is calculated with the first element of the other, and so on.\nv1 &lt;- c( 1,  3,  5,  7)\nv2 &lt;- c(20, 40, 60, 80)\n  \nv1 + v2\n## [1] 21 43 65 87\n\nv2 * v1\n## [1]  20 120 300 560\nHowever, if the two vectors are of different lengths, the shorter will be “recycled” until the length of the other vector is reached (“recycling rule”):\nv3 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nv4 &lt;- c(10, 1)  \n\nv3 + v4\n##  [1] 11  3 13  5 15  7 17  9 19 11\nThere are many useful functions in R that speed up data analysis. Here are some functions that are already implemented in the base package and thus in every basic installation of R:\nv5 &lt;- c(2, 4, 6, 8, 1, 3)\n\nmean(v5)                    # arithmetisches Mittel des Vektors\n## [1] 4\n\nmedian(v5)                  # median\n## [1] 3.5\n\nmax(v5)                     # maximum value\n## [1] 8\n\nmin(v5)                     # minimum value\n## [1] 1\n\nsum(v5)                     # sum of all elements\n## [1] 24\n\nquantile(v5)                # quantiles\n##   0%  25%  50%  75% 100% \n## 1.00 2.25 3.50 5.50 8.00\n\nvar(v5)                     # variance\n## [1] 6.8\n\nsd(v5)                      # standard deviation\n## [1] 2.607681\n\nsort(v5, decreasing=TRUE)   # sort elements\n## [1] 8 6 4 3 2 1\n\n\nFactors\nAnother class that you might will stumble upon when working with datasets is the factors. Factors represent categorical data and are beneficial for many statistical analyzes as well as plotting the data. When importing data into R, strings are automatically converted to factors by default:\n# unordered factor vector\nfa &lt;- factor( c(\"good\", \"bad\", \"bad\", \"bad\", \"good\", \"good\") )\n\nclass(fa)\n## [1] \"factor\"\n\nfa\n## [1] good bad  bad  bad  good good\n## Levels: bad good\n\nstr(fa)\n##  Factor w/ 2 levels \"bad\",\"good\": 2 1 1 1 2 2\n\nas.integer(fa)\n## [1] 2 1 1 1 2 2\n\nlevels(fa)\n## [1] \"bad\"  \"good\"\nFactors are based on integer values, which we can show with the function str(): Each individual expression in the vector represents a level and is assigned to an integer value (in this case good is 2 and bad is 1) ). The assignment of the integer values ​​takes place alphabetically for character vectors.\nSo much for vectors in R. It is time for you to become active:"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-III/index.html",
    "href": "R-Crash-Course/contents/Part-III/index.html",
    "title": "Part III",
    "section": "",
    "text": "Part III\n\n\n6. Matrices\nA matrix is a two-dimensional data structure and only contains elements of a single class. It can be created via matrix() by defining a number of rows nrow and columns ncol of a given vector:\nm &lt;- matrix(1:6, nrow = 3, ncol = 2) \nm\n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\n\nlength(m)      # shows number of elements in matrix\n## [1] 6\n\ndim(m)         # shows nrow und ncol attributes\n## [1] 3 2\nThe colon in expression 1:6 in line 1 is the sequential operator, which in this case creates a vector of all integer values between 1 and 6.\nA matrix can also be constructed from vectors by using the dim () function to define the dimensionality:\na &lt;- 1:16\na\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n\ndim(a) &lt;- c(2,8)\na\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n## [1,]    1    3    5    7    9   11   13   15\n## [2,]    2    4    6    8   10   12   14   16\nFurthermore, we can connect two vectors to each other via cbind() (column bind) or rbind() (row bind). If the vectors do not have the same length, they would be padded with NA values.\nx &lt;- c(23, 44, 15, 12)\ny &lt;- c( 1,  2,  3,  4)\n\nb &lt;- cbind(x, y)\nb\n##       x y\n## [1,] 23 1\n## [2,] 44 2\n## [3,] 15 3\n## [4,] 12 4\n\nc &lt;- rbind(x, y)\nc\n##   [,1] [,2] [,3] [,4]\n## x   23   44   15   12\n## y    1    2    3    4\nIf more than two dimensions are needed, e.g., when working with remote sensing imagery, we use arrays. These behave like matrices, but have at least three dimensions (help(array)).\nIndexing in matrices\nIndexing in matrices behaves adequately to indexing in vectors, except that we now put two index numbers in the square brackets [] to address rows and columns. Both numbers must always be separated by a comma \\[line, column\\]. If we want all the entries from one dimension, we simply leave the corresponding slot for the index numbers empty:\nm &lt;- matrix(1:15, nrow = 5, ncol = 3) \nm\n##      [,1] [,2] [,3]\n## [1,]    1    6   11\n## [2,]    2    7   12\n## [3,]    3    8   13\n## [4,]    4    9   14\n## [5,]    5   10   15\n\nm[ , 2]                     # extract second column\n## [1]  6  7  8  9 10\n\nm[3,  ]                     # extract third row\n## [1]  3  8 13\n\nm[1, c(2, 3)]               # elements of first row in 2nd and 3rd column\n## [1]  6 11\nCalculate with matrices\nR is an equally powerful tool in terms of linear algebra. Appropriate to the vectors, whole matrices can be multiplied by a single value (scalar multiplication) or element by element. For the latter, however, the matrices necessarily need the same dimensionality dim().\nm1 &lt;- matrix(1:8, nrow = 2)\nm1\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    3    5    7\n## [2,]    2    4    6    8\n\nm1 * 5                         # scalar multiplication\n##      [,1] [,2] [,3] [,4]\n## [1,]    5   15   25   35\n## [2,]   10   20   30   40\n\nm1 * m1                        # multiplication element-wise\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    9   25   49\n## [2,]    4   16   36   64\nSome useful and commonly used functions:\nm2 &lt;- matrix(1:6, nrow = 2)\nm2\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\n\ncolMeans(m2)               # mean of all columns\n## [1] 1.5 3.5 5.5\n\ncolSums(m2)                # sum of all columns\n## [1]  3  7 11\n\nrowMeans(m2)               # mean of all rows\n## [1] 3 4\n\nrowSums(m2)                # sum of all rows\n## [1]  9 12\n\nt(m2)                      # transpose a matrix\n##      [,1] [,2]\n## [1,]    1    2\n## [2,]    3    4\n## [3,]    5    6\n\nm3 &lt;- matrix(1:6, ncol = 2)\nm3 %*% m2                  # matrix multiplication\n##      [,1] [,2] [,3]\n## [1,]    9   19   29\n## [2,]   12   26   40\n## [3,]   15   33   51\nMatrix multiplications assume that the inner dimensions of the two matrices are the same length (here you will find further information).\nNext training session incoming:"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-IV/index.html",
    "href": "R-Crash-Course/contents/Part-IV/index.html",
    "title": "Part IV",
    "section": "",
    "text": "Part IV\n\n\n\n7. Lists\nA list is a special form of a vector that allows multiple elements of different classes at once. It thus serves as a kind of container for other objects, such as numbers, strings, vectors or matrices. A list can be created using the function list(). Element names can be given to existing lists via the names() function so that they can later be indexed using these names:\nl &lt;- list(13L, \"Hello\", matrix(1:6, 2, 3))\nl\n## [[1]]\n## [1] 13\n## \n## [[2]]\n## [1] \"Hello\"\n## \n## [[3]]\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\n\nnames(l) &lt;- c(\"my.integer\", \"my.string\", \"my.matrix\")\nl\n## $my.integer\n## [1] 13\n## \n## $my.string\n## [1] \"Hello\"\n## \n## $my.matrix\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\n\nstr(l)\n## List of 3\n##  $ my.integer: int 13\n##  $ my.string: chr \"Hello\"\n##  $ my.matrix: int [1:2, 1:3] 1 2 3 4 5 6\nWhen creating a list, however, the element names can also be assigned immediately:\nl &lt;- list(\"my.integer\"=13L,\n          \"my.string\"=\"Hello\",\n          \"my.matrix\"=matrix(1:6, 2, 3)\n          )\nIndexing in lists\nUsing the respective index number or the assigned element name (if available), we can use a double square bracket [\\[\\[\\]]]{.crayon-inline} to access the contents of the list. Using a simple square bracket, we would only get a part of the list here, which would still belong to class list:\nl[1]                        # first part of the list\n## $my.integer\n## [1] 13\nclass(l[1])\n## [1] \"list\"\n\nl[[1]]                      # extract first element (integer value)\n## [1] 13\nclass(l[[1]])\n## [1] \"integer\"\n\nl[[\"my.string\"]]           # extract element by its name\n## [1] \"Hello\"\n\nl[[3]]                      # extract third element (matrix)\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nModify lists\nLists can be expanded (assign a new index number or new element name to a value), and elements can be deleted (assign NULL) or overwrite individual list elements (reassign existing index or name):\nl[\"my.numeric\"] &lt;- 45.7325          # add new element to list\n\nl[1] &lt;- NULL                         # delete first element in list\n\nl[\"meinString\"] &lt;- \"World\"           # overwrite existing element\n\n\n\n\n8. Dataframe\nThe data frame is the most commonly used data type when manipulating databases and allows you to manage two-dimensional tabular data. Where is the difference to a matrix? Well, while a matrix can only contain elements of a class, several classes can exist in one data frame. Each column in a data frame is basically a list.\nWhenever external data is read into R, a data frame is created.\ndf &lt;- data.frame(\n  \"name\"   = c(\"Ben\", \"Hanna\", \"Paul\", \"Arthur\"), \n  \"size\"   = c(185, 166, 175, 190),\n  \"weight\" = c(110, 60, 76, 89)\n  )\n\ndf\n##     name size weight\n## 1    Ben  185    110\n## 2  Hanna  166     60\n## 3   Paul  175     76\n## 4 Arthur  190     89\n\nlength(df)                  # number of columns (variables)\n## [1] 3\n\ndim(df)                     # dimensionen (4 rows, 3 columns)\n## [1] 4 3\n\nnrow(df)                    # number of rows (observations)\n## [1] 4\n\nncol(df)                    # number of columns (variables)\n## [1] 3\n\nstr(df)                     # shows structure of df\n## 'data.frame':    4 obs. of  3 variables:\n##  $ name  : Factor w/ 4 levels \"Arthur\",\"Ben\",..: 2 3 4 1\n##  $ size  : num  185 166 175 190\n##  $ weight: num  110 60 76 89\n\nsummary(df)                 # statistical summary\n##      name       size            weight\n##  Arthur:1   Min.   :166.0   Min.   : 60.00  \n##  Ben   :1   1st Qu.:172.8   1st Qu.: 72.00  \n##  Hanna :1   Median :180.0   Median : 82.50  \n##  Paul  :1   Mean   :179.0   Mean   : 83.75  \n##             3rd Qu.:186.2   3rd Qu.: 94.25  \n##             Max.   :190.0   Max.   :110.00\nInteresting is the output of the function str(). He first shows us that we have 4 observations (obs., Ie “Ben”, “Hanna”, “Paul”, “Arthur”) with 3 variables each (variables, ie “name,” “size”, “weight”) Furthermore, for each variable it is determined whether it is numeric (num) or categorial (factor), for the latter the number of different values (w / 4 levels) is displayed, and even more useful is the statistical summary for each column of the Data frames via the function summary()!\nIndexing in data frames\nIn a data frame columns can be addressed either by the double square brackets [\\[\\[\\]]]{.crayon-inline} by means of index numbers or directly by the name of the column (if available) by means of the dollar sign $. In addition, the rows or columns can be addressed adequately to a matrix by means of simple square brackets[]:\ndf\n##     name size weight\n## 1    Ben  185    110\n## 2  Hanna  166     60\n## 3   Paul  175     76\n## 4 Arthur  190     89\n\ndf[2]                                  # output column 2 as data frame\n##   size\n## 1  185\n## 2  166\n## 3  175\n## 4  190\n\ndf[[2]]                                # output as numeric\n## [1] 185 166 175 190\n\ndf$size                                # output as numeric\n## [1] 185 166 175 190\n\ndf[ , 2]                               # column output as numeric\n## [1] 185 166 175 190\n\ndf[1,  ]                               # row output as data frame\n##   name size weight\n## 1  Ben  185    110\n\ndf[1, 2]                               # element in row 1, col 2 as numeric\n## [1] 185\nVarious queries are also possible, for which we use the boolean operators:\ndf\n##     name size weight\n## 1    Ben  185    110\n## 2  Hanna  166     60\n## 3   Paul  175     76\n## 4 Arthur  190     89\n\ndf$size &gt; 170\n## [1]  TRUE FALSE  TRUE  TRUE\n\ndf[df$size &gt; 170, ]                     \n##     name size weight\n## 1    Ben  185    110\n## 3   Paul  175     76\n## 4 Arthur  190     89\n\ndf[df$size &gt; 180 & df$weight &lt; 100, ]        # AND condition\n##     name size weight\n## 4 Arthur  190     89\n\ndf[df$size &gt; 188 | df$weight &lt; 70, ]         # OR condition\n##     name size weight\n## 2  Hanna  166     60\n## 4 Arthur  190     89\n\ndf[df$name == \"Ben\" | df$name == \"Hanna\", ]  # OR condition\n##    name size weight\n## 1   Ben  185    110\n## 2 Hanna  166     60\nExplanation: For queries we use boolean operators. By the query in line 8 we get a boolean Vector, which contains a TRUE if the respective value of the Observation is greater than 170. We use this vector in line 11 to index the corresponding entries in the data frame (outputs all observations with a TRUE). When chaining conditions, either both conditions must be fulfilled at the same time by using AND &, or only one of both by using OR |.\nModify data frames\nOften it is necessary to delete data from a data frame or to implement additional entries later. For both tasks there are several possibilities in R. In the following two simple solutions:\ndf2 &lt;- df[ , -2]                                # delete column by index\ndf2\n##     name weight\n## 1    Ben    110\n## 2  Hanna     60\n## 3   Paul     76\n## 4 Arthur     89\n\ndf3 &lt;- subset(df, select = -c(weight, size))    # delete column by name\ndf3\n##     name\n## 1    Ben\n## 2  Hanna\n## 3   Paul\n## 4 Arthur\n\ndf4 &lt;- df[-3, ]                                 # delet row by index\ndf4\n##     name size weight\n## 1    Ben  185    110\n## 2  Hanna  166     60\n## 4 Arthur  190     89\n\ndf5 &lt;- subset(df, !name %in% c(\"Ben\", \"Hanna\")) # delete row by attribute\ndf5\n##     name size weight\n## 3   Paul  175     76\n## 4 Arthur  190     89\nExcluding columns via the column name is possible via the subset() function. Here we can use the argument -select= with a leading minus to specify the name of the column to be deleted (or a vector with c() for several columns at the same time). The ! symbol is a logical operator and negates a condition (see ? “!”).\nThe addition of observations and variables is of course also possible:\ndf$gender = c(\"m\", \"w\", \"m\", \"m\")         # add a column (variable)\ndf\n##     name size weight gender\n## 1    Ben  185    110      m\n## 2  Hanna  166     60      w\n## 3   Paul  175     76      m\n## 4 Arthur  190     89      m\n\nnewdata &lt;- data.frame(\"name\" = 'Lisa',    # add a row (observation)\n                      \"size\" = 180,\n                      \"weight\" = 70,\n                      \"gender\" = \"w\"\n                      )\n\ndf &lt;- rbind(df, newdata)\ndf\n##     name size weight gender\n## 1    Ben  185    110      m\n## 2  Hanna  166     60      w\n## 3   Paul  175     76      m\n## 4 Arthur  190     89      m\n## 5   Lisa  180     70      w\nIf a new line has to be added, the new data must have the same structure as the existing data frame.\nTime for training session number IV:"
  },
  {
    "objectID": "R-Crash-Course/contents/Part-V/index.html",
    "href": "R-Crash-Course/contents/Part-V/index.html",
    "title": "Part V",
    "section": "",
    "text": "Part V\n\n\n\n9. Missing values\nSometimes observations (rows) in a data frame are incomplete. The correct handling of missing values is especially needed in statistical evaluations. Missing values are indicated by the symbol NA (Not Available). Non-possible values (e.g., division by 0) are described by the symbol NaN (Not a Number). For test purposes, we artificially define two elements as NA in our df:\ndf &lt;- data.frame(\n  \"name\" = c(\"Ben\", \"Hanna\", \"Paul\", \"Arthur\"), \n  \"size\" = c(185, 166, 175, 190)\n  )\n\ndf\n##     name size\n## 1    Ben  185\n## 2  Hanna  166\n## 3   Paul  175\n## 4 Arthur  190\n\ndf[1:2, 2] &lt;- NA              # generate NAs\ndf\n##     name size\n## 1    Ben   NA\n## 2  Hanna   NA\n## 3   Paul  175\n## 4 Arthur  190\n\nmean(df$size)                 # mean with NAs\n## [1] NA\n\nmean(df$size, na.rm=TRUE)     # mean with ignoring NAs\n## [1] 182.5\nOften it makes more sense to record the observations with missing values and to exclude them from your dataset. For detection we can use the is.na() function to create a logical vector. This outputs a TRUE for every NA value, a FALSE for every element present. Using the logical vector we can then index our data frame:\nis.na(df$size)               # logical vector (TRUE for all rows with NAs)\n## [1]  TRUE  TRUE FALSE FALSE\n\ndf[is.na(df$size), ]         # index using logical vector\n##    name size\n## 1   Ben   NA\n## 2 Hanna   NA\n\ndf[complete.cases(df), ]     # get all rows without NAs\n##     name size\n## 3   Paul  175\n## 4 Arthur  190\n\n\n\n\n10. Control Structures\nControl structures allow better control over the execution of our scripts, e.g., if, if else, else, while, switch, repeat, break, return …\nUse the help function for a more detailed documentation.\nThe IF statement\nUse the if / else command to perform simple queries on all data types. The Microsoft Excel equivalent would be the “IF” feature. In R, the syntax is as follows:\nx &lt;- 3                                # define x\n\nx &lt;= 4                                # logical condition\n## [1] TRUE\n\nif (x &lt;= 4) {\n  print(\"x is smaller than or equal to 4!\")    \n} else {\n  print(\"x is larger than 4!\")        \n}\n## [1] \"x is smaller than or equal to 4!\"\nExplanation: An IF-command needs three parts: the keyword if(), a condition that results in a single logical output x &lt;= 4 and a block of code in curly braces {}, which is executed if the expression is TRUE. So, if the condition is TRUE, the code will run in curly brackets after the IF-command. If the condition is FALSE, the code block after the elseis executed.\nThe print() function outputs the strings in the parentheses to the console window. Here we need the print() function so that the output can be written out of the IF-function, similar to return(see chapter 5). A vectorized (and therefore more efficient) notation is the following:\nx &lt;- c(3, 4, 5, 6, 7)                                \n\nifelse(x &lt;=4, \"x is smaller than or equal to 4!\", \"x is larger than 4!\")\n## [1] \"x is smaller than or equal to 4!\" \"x is smaller than or equal to 4!\"\n## [3] \"x is larger than 4!\"              \"x is larger than 4!\"             \n## [5] \"x is larger than 4!\"\nUsing ifelse(), the condition for each individual element is determined as a vector. This is helpful, e.g., if we want to categorize data!\nThe FOR loop\nLoops are incredibly useful when certain tasks need to be repeated very often in the script. A for loop is based on an iterable variable of defined length. But what does that mean? We define any variable, e.g., i, with a start integer value, e.g, 1. We then increment this integer value until a second integer value, e.g. 8, is reached. This can be done via the sequence operator ::\nfor (i in 1:8) {\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\nThe practical thing: The code in curly brackets is automatically executed once each time (eight times in total)! And we can meanwhile pick up the expression of our variable i, in order to print it or index a vector with it and much more:\nv &lt;- c(23, 54, 12, 59, 67, 45)    # create integer vector\n\nlength(v)                         # check length of vector\n## [1] 6\n  \nfor (i in 1:length(v)) {          # iterate length(v) times\n  print(v[i])\n}\n## [1] 23\n## [1] 54\n## [1] 12\n## [1] 59\n## [1] 67\n## [1] 45\nIt is also possible to set the variable / iterator equal to the elements of the vector instead of an integer value for indexing. The information in which run the loop is, however, is initially lost:\nv &lt;- c(\"R\", \"is\", \"still\", \"fun\")    \n\nfor (i in v) {\n  print(i)\n}\n## [1] \"R\"\n## [1] \"is\"\n## [1] \"still\"\n## [1] \"fun\"\nNow, have a look at exercise V:"
  },
  {
    "objectID": "R-Crash-Course/index.html",
    "href": "R-Crash-Course/index.html",
    "title": "R Crash Course",
    "section": "",
    "text": "R Crash Course\n\n\nThis is a R crash course for anyone who previously had no or very little contact with script-based programming. It should establish the basic understanding needed for upcoming chapters.\nYou are an old hand in R programming and do not need this introduction? – Skip this section and jump to the next!\nIn order to deepen your knowledge, in particular with a view to statistical analysis, we recommend the advanced e-learning course SOGA (Softwaregestützte Geodatenanalyse). User name and password for SOGA are “ilovestats” in a single word. Of course, there are lots of advanced tutorials and relevant literature out there, which should not go unmentioned here.\n\nCrash Course in a Box\nWe subdivided this crash course into several sections. At the end of most sections you will get to test your knowledge with coding exercises (E)!\n\nPart I + E I:\n\nPackage Management\nCalculate With R\nVariables\nFunctions\n\nPart II + E II:\n\nVectors\nFactors\n\nPart III + E III:\n\nMatrices\n\nPart IV + E IV:\n\nLists\n\nPart V + E V:\n\nMissing values\nControl structures"
  },
  {
    "objectID": "RESEDA/index.html",
    "href": "RESEDA/index.html",
    "title": "RESEDA",
    "section": "",
    "text": "to your Remote Sensing Data Analysis online course, or RESEDA for short!\nThis course helps you improve your analysis of remote sensing image data for the next data science project or thesis. We will have a look at basic and advanced concepts needed for a complete project implementation using remote sensing imagery – with a special focus on automatisation of individual operations and big data processing. This course will provide a great deal of knowledge and valuable expertise for all related fields of environmental earth sciences!\nFor that purpose we will mainly use the statistical programming language R in a Linux environment – but please don’t panic, it’s not as bad as it sounds: You will be led through a complete analysis process, from data acquisition, to import, exploration and finally the export of your results, guided by a lot of reproduceable examples, exercises and pretty pictures!\nKeep in mind that this course content complements and extends the material covered in the classes Fernerkundung und Digitale Bildverarbeitung and Geographische Informationssysteme, both being taught at the Freie Universität Berlin.\nPlease feel free to contact me if you have any questions or would like to discuss potential projects."
  },
  {
    "objectID": "RESEDA/index.html#learning-objectives",
    "href": "RESEDA/index.html#learning-objectives",
    "title": "RESEDA",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nThis online course is divided into separate sections covering particular topics, which together provide a whole workflow commonly used for remote sensing imagery. Although the sections are built on one another and we recommend to handle them in given order, feel free to skip parts you are already comfortable with and focus on the chapters you are interested in. In almost every section you will come across exercises, e.g., multiple choice questionnaires or coding exercises to proof your comprehension of previous sections.\nLet us have a look at the learning objectives and checkpoints of each individual section:\n\nPrepare Yourself\ninstall our VirtualBox containing all required software get used to the GUIs of R-Studio, QGIS and SNAP refresh basics of the programming language R (if needed)\n\n\nAcquire Data\n\nrepeat basics of optical and radar imagery\nbecome familiar with online data provider and HUBs\nautomatically download many images using bulk downloads\n\n\n\nAnalyse Your Data\n\nrepeat basics of classification and regression tasks\nclassify image data in R with Random Forest and SVM\nvisualize results in R and QGIS\n\n\n\nValidate Results\n\nrepeat validation basics\nvalidate results in R with state of the art methods\n\n\n\nSAR Processing\n\nget deeper insights in SAR processing\nprocess Sentinel imagery in SNAP\nlearn to do InSAR and texture analysis\n\nWe wish you a lot of creative ideas, much findings and great results!\nBest regards, your FU Berlin Remote Sensing and Geoinformatics staff"
  }
]